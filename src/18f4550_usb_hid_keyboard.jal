-- Title: USB HID keyboard device demo
-- Author: Albert Faber, Copyright (c) 2008..2010, all rights reserved.
-- Adapted-by: -
-- Compiler: >=2.4l
-- Revision: $Revision: 3043 $
-- 
-- This file is part of jallib (http://jallib.googlecode.com)
-- Released under the BSD license (http://www.opensource.org/licenses/bsd-license.php)
-- 
-- Description: This application emulates a keyboard USB human interface device
-- (HID), once the USB device has been conifgured and the USB HID device is recognized by
-- the host operating systems, it will generate keyboard chars if boot program pin is low
-- 
-- 
-- Sources: http://www.usb.org for USB specifications
-- 
-- Notes: compiled with following flags
--	none when using no bootloader
--	when using bootloader: -loader18 -no-fuse 
--	use -no-variable-reuse when debugging flags are
--  set due to a compiler issue
--
-- ------------------------------------------------------
-- ------------------------------------------------------
--
--
--
-- This file has been generated by jallib.py from:
--    * board: board_18f4550_af.jal
--    * test : test_usb_hid_keyboard.jal
--

;@jallib section chipdef
-- chip setup
include 18f4550

-- even though the external crystal is 20 MHz, the configuration is such that
-- the CPU clock is derived from the 96 Mhz PLL clock (div2), therefore set
-- target frequency to 48 MHz
pragma target clock       48_000_000


-- fuses
pragma target PLLDIV        P5          -- divide by 5 - 20MHZ_INPUT
pragma target CPUDIV        P1          -- [primary oscillator src: /1][96 mhz pll src: /2]
pragma target USBPLL        F48MHZ      -- CLOCK_SRC_FROM_96MHZ_PLL_2
pragma target OSC           HS_PLL
pragma target FCMEN         DISABLED
pragma target IESO          DISABLED
pragma target PWRTE         DISABLED    -- power up timer
pragma target VREGEN        ENABLED     -- USB voltage regulator
pragma target VOLTAGE       MINIMUM     -- brown out voltage
pragma target BROWNOUT      DISABLED    -- no brownout detection
pragma target WDTPS         P32K        -- watch dog saler setting
pragma target WDT           DISABLED    -- no watchdog
pragma target CCP2MUX       ENABLED     -- CCP2 pin C1
pragma target PBADEN        DIGITAL     -- digital input port<0..4>
pragma target LPT1OSC       LOW_POWER   -- low power timer 1
pragma target MCLR          EXTERNAL    -- master reset on RE3
pragma target STVR          DISABLED    -- reset on stack over/under flow
pragma target LVP           DISABLED    -- no low-voltage programming
pragma target XINST         ENABLED     -- extended instruction set
pragma target DEBUG         DISABLED    -- background debugging
pragma target CP0           DISABLED    -- code block 0 not protected
pragma target CP1           DISABLED    -- code block 1 not protected
pragma target CP2           DISABLED    -- code block 2 not protected
pragma target CP3           DISABLED    -- code block 3 not protected
pragma target CPB           DISABLED    -- bootblock code not write protected
pragma target CPD           DISABLED    -- eeprom code not write protected
pragma target WRT0          DISABLED    -- table writeblock 0 not protected
pragma target WRT1          DISABLED    -- table write block 1 not protected
pragma target WRT2          DISABLED    -- table write block 2 not protected
pragma target WRT3          DISABLED    -- table write block 3 not protected
pragma target WRTB          DISABLED    -- bootblock not write protected
pragma target WRTD          DISABLED    -- eeprom not write protected
pragma target WRTC          DISABLED    -- config not write protected
pragma target EBTR0         DISABLED    -- table read block 0 not protected
pragma target EBTR1         DISABLED    -- table read block 1 not protected
pragma target EBTR2         DISABLED    -- table read block 2 not protected
pragma target EBTR3         DISABLED    -- table read block 3 not protected
pragma target EBTRB         DISABLED    -- boot block not protected


include delay
include pic_data_eeprom
;@jallib section serial
const serial_hw_baudrate = 115_200
;@jallib section bootloader
alias bootloader_program_pin    is pin_b5
alias bootloader_program_pin_direction  is pin_b5_direction
;@jallib section led
-- LED IO definition
-- alias led is pin_b3
--alias led_direction is pin_b3_direction
--alias led2 is pin_b1
--alias led2_direction is pin_b1_direction

alias C1 is pin_D4
alias C2 is pin_D5
alias C3 is pin_D6
alias C4 is pin_D7
alias C5 is pin_B2
alias C6 is pin_B3
alias C7 is pin_B4
alias C8 is pin_B5
alias C9 is pin_B6
alias C10 is pin_B7
alias C11 is pin_A0
alias C12 is pin_A1
alias C13 is pin_A2
alias C14 is pin_A3
alias C15 is pin_A4
alias C16 is pin_A5
alias C17 is pin_E0
alias R1 is pin_E1
alias R2 is pin_E2
alias R3 is pin_C0
alias R4 is pin_C1
alias R5 is pin_C2
alias R6 is pin_D0
alias SW_PEN is pin_D2

alias neopixels is pin_B0

-- setup i2c hardware
const word _i2c_bus_speed = 1 ; * 100kHz
var bit _i2c_level = true   ; i2c levels (not SMB)
alias i2c_scl            is pin_scl
alias i2c_scl_direction  is pin_scl_direction
alias i2c_sda            is pin_sda
alias i2c_sda_direction  is pin_sda_direction

include i2c_software
i2c_initialize()
include eeprom_24lc256 -- include 24lc256 eeprom
var byte data

include usb_keyboard

-- set all inputs to digital
enable_digital_io()

PORTE = 0x00
LATE = 0
LATC = 0
TRISE = 0xff
ADCON1 = 0x0a

-- setup direction bits
-- led_direction = output
-- led2_direction = output
bootloader_program_pin_direction = input
pin_D4_direction = output
pin_D5_direction = output
pin_D6_direction = output
pin_D7_direction = output
pin_B2_direction = output
pin_B3_direction = output
pin_B4_direction = output
pin_B5_direction = output
pin_B6_direction = output
pin_B7_direction = output
pin_A0_direction = output
pin_A1_direction = output
pin_A2_direction = output
pin_A3_direction = output
pin_A4_direction = output
pin_A5_direction = output
pin_E0_direction = output
pin_E2_direction = input
pin_E1_direction = input
pin_C0_direction = input
pin_C1_direction = input
pin_C2_direction = input
pin_D0_direction = input
pin_B0_direction = output
pin_D2_direction = output

var byte pos = 1
var byte incColor = 1
var byte decColor = 0
var byte colorfactorR = 1
var byte colorfactorG = 1
var byte colorfactorB = 1
var byte direction = 0
var byte rgbColour[3]
var byte ledmode = 0
var word timecounter = 0
var byte aux = 0
var byte aux2 = 0
var byte f_index[12]
var byte key_value = 0x00
var byte modifier = 0x00
var byte mode = 0
var byte color_mode = 0
var byte log_mode = 0
var byte save_mode = 0
var word counter[12]
var word ssa[12]
var dword logcounter = 0
var word csa = 0x00
var word cpa = 0x00
var word cla = 0x708
var byte inhibit = 0
var byte log_status = 0
var byte g = 0
var byte d = 0
var byte z = 0
var byte r = 0
var byte key_index = 0
var byte hid_report_in[8]
var byte queue[7]
var byte key_pressed[88] -- 1 is pressed, 0 is nonpressed
var byte current[88] -- 1 is pressed, 0 is nonpressed
var byte previous[88] -- 1 is pressed, 0 is nonpressed
var byte bounce[88] 
var byte type[88]
var byte keys[88]


rgbColour[0] = 0
rgbColour[1] = 0
rgbColour[2] = 0

--Initialize keys
keys[0] = 0x29 -- ESCAPE
type[0] = 0
keys[1] = 0x35 -- BACKSLASH
type[1] = 0
keys[2] = 0x2b -- TAB
type[2] = 0
keys[3] = 0x39 -- CAPS LOCK
type[3] = 0
keys[4] = USB_KEYBOARD_MKEY_LEFT_SHIFT -- LEFT SHIFT
type[4] = 1
keys[5] = USB_KEYBOARD_MKEY_LEFT_CTRL -- LEFT CONTROL
type[5] = 1
keys[6] = 0x1E -- 1
type[6] = 0
keys[7] = 0x14 -- Q
type[7] = 0
keys[8] = 0x04 -- A 
type[8] = 0
keys[9] = 0x64 -- LESS
type[9] = 0
keys[10] = USB_KEYBOARD_MKEY_LEFT_GUI -- LEFT SUPER
type[10] = 1
keys[11] = 0x3A -- F1
type[11] = 0
keys[12] = 0x1F -- 2
type[12] = 0
keys[13] = 0x1A -- W
type[13] = 0
keys[14] = 0x16 -- S
type[14] = 0
keys[15] = 0x1D --  Z
type[15] = 0
keys[16] = USB_KEYBOARD_MKEY_LEFT_ALT -- LEFT ALT
type[16] = 1
keys[17] = 0x3B -- F2
type[17] = 0
keys[18] = 0x20 -- 3
type[18] = 0
keys[19] = 0x08 -- E 
type[19] = 0
keys[20] = 0x07 -- D 
type[20] = 0
keys[21] = 0x1B -- X
type[21] = 0
keys[22] = 0x3C -- F3
type[22] = 0
keys[23] = 0x21 -- 4
type[23] = 0
keys[24] = 0x15 -- R
type[24] = 0
keys[25] = 0x09 -- F
type[25] = 0
keys[26] = 0x06 -- C
type[26] = 0
keys[27] = 0x3D -- F4
type[27] = 0
keys[28] = 0x22 -- 5
type[28] = 0
keys[29] = 0x17 -- T
type[29] = 0
keys[30] = 0x0A -- G 
type[30] = 0
keys[31] = 0x19 -- V
type[31] = 0
keys[32] = 0x3E -- F5
type[32] = 0
keys[33] = 0x23 -- 6
type[33] = 0
keys[34] = 0x1C -- Y
type[34] = 0
keys[35] = 0x0B -- H
type[35] = 0
keys[36] = 0x05 -- B
type[36] = 0
keys[37] = 0x2C -- SPACE
type[37] = 0
keys[38] = 0x3F -- F6
type[38] = 0
keys[39] = 0x24 -- 7
type[39] = 0
keys[40] = 0x18 -- U
type[40] = 0
keys[41] = 0x0D -- J
type[41] = 0
keys[42] = 0x11 -- N
type[42] = 0
keys[43] = 0x40 -- F7
type[43] = 0
keys[44] = 0x25 -- 8
type[44] = 0
keys[45] = 0x0C -- I
type[45] = 0
keys[46] = 0x0E -- K
type[46] = 0
keys[47] = 0x10 -- M
type[47] = 0
keys[48] = 0x41 -- F8
type[48] = 0
keys[49] = 0x26 -- 9
type[49] = 0
keys[50] = 0x12 -- O
type[50] = 0
keys[51] = 0x0F -- L
type[51] = 0
keys[52] = 0x36 -- COMMA
type[52] = 0
keys[53] = USB_KEYBOARD_MKEY_RIGHT_ALT -- RIGHT ALT
type[53] = 1
keys[54] = 0x42 -- F9
type[54] = 0
keys[55] = 0x27 --  0
type[55] = 0
keys[56] = 0x13 -- P
type[56] = 0
keys[57] = 0x33 -- Ç
type[57] = 0
keys[58] = 0x37 -- PERIOD
type[58] = 0
keys[59] = USB_KEYBOARD_MKEY_RIGHT_GUI -- RIGHT SUPER
type[59] = 1
keys[60] = 0x43 -- F10
type[60] = 0
keys[61] = 0x2D -- APOSTROPHE
type[61] = 0
keys[62] = 0x2F -- PLUS
type[62] = 0
keys[63] = 0x34 -- MASCULINE
type[63] = 0
keys[64] = 0x38 -- MINUS
type[64] = 0
keys[65] = 0x44 --  F11
type[65] = 0
keys[66] = 0x2E -- GUILLEMOT LEFT
type[66] = 0
keys[67] = 0x30 -- DEAD ACUTE
type[67] = 0
keys[68] = 0x31 -- TILDE
type[68] = 0
keys[69] = 0x65 -- MENU
type[69] = 0
keys[70] = 0x45 -- F12
type[70] = 0
keys[71] = 0x2A -- BACKSPACE
type[71] = 0
keys[72] = 0x28 -- ENTER
type[72] = 0
keys[73] = USB_KEYBOARD_MKEY_RIGHT_SHIFT -- RIGHT SHIFT
type[73] = 1
keys[74] = USB_KEYBOARD_MKEY_RIGHT_CTRL -- RIGHT CONTROL
type[74] = 1
keys[75] = 0x46 -- PRINT SCREEN
type[75] = 0
keys[76] = 0x49 -- INSERT
type[76] = 0
keys[77] = 0x4C -- DELETE
type[77] = 0
keys[78] = 0x50 -- LEFT ARROW
type[78] = 0
keys[79] = 0x47 -- SCROLL LOCK
type[79] = 0
keys[80] = 0x4A -- HOME
type[80] = 0
keys[81] = 0x4D -- END
type[81] = 0
keys[82] = 0x52 -- UP ARROW
type[82] = 0
keys[83] = 0x51 -- DOWN ARROW
type[83] = 0
keys[84] = 0x48 -- PAUSE
type[84] = 0
keys[85] = 0x4B -- PAGE UP
type[85] = 0
keys[86] = 0x4E -- PAGE DOWN
type[86] = 0
keys[87] = 0x4F -- RIGHT ARROW
type[87] = 0

-- intialize the library
usb_keyboard_init()

-- testing leds

-- var byte blue = 0
-- var byte red = 10
-- var byte green = 30

var byte red[4]
var byte green[4]
var byte blue[4]

red[0] = data_eeprom(0)
green[0] = data_eeprom(1)
blue[0] = data_eeprom(2)
red[1] = data_eeprom(3)
green[1] = data_eeprom(4)
blue[1] = data_eeprom(5)
red[2] = data_eeprom(6)
green[2] = data_eeprom(7)
blue[2] = data_eeprom(8)
red[3] = data_eeprom(9)
green[3] = data_eeprom(10)
blue[3] = data_eeprom(11)

log_mode = data_eeprom(12)

var byte red_ = red[0]
var byte green_ = green[0]
var byte blue_ = blue[0]

counter[0] = data_eeprom_word(20)
counter[1] = data_eeprom_word(22)
counter[2] = data_eeprom_word(24)
counter[3] = data_eeprom_word(26)
counter[4] = data_eeprom_word(28)
counter[5] = data_eeprom_word(30)
counter[6] = data_eeprom_word(32)
counter[7] = data_eeprom_word(34)
counter[8] = data_eeprom_word(36)
counter[9] = data_eeprom_word(38)
counter[10] = data_eeprom_word(40)
counter[11] = data_eeprom_word(42)
logcounter = data_eeprom_dword(44)
ssa[0] = 0x00
ssa[1] = 0x96
ssa[2] = 0x12C
ssa[3] = 0x1C2
ssa[4] = 0x258
ssa[5] = 0x2EE
ssa[6] = 0x384
ssa[7] = 0x41A
ssa[8] = 0x4B0
ssa[9] = 0x546
ssa[10] = 0x5DC
ssa[11] = 0x672
f_index[0] = 11
f_index[1] = 17
f_index[2] = 22
f_index[3] = 27
f_index[4] = 32
f_index[5] = 38
f_index[6] = 43
f_index[7] = 48
f_index[8] = 54
f_index[9] = 60
f_index[10] = 65
f_index[11] = 70


procedure send() is
	var byte y = 0
	hid_report_in[0] = modifier
	for 6 loop
		if queue[y] < 255 then
			hid_report_in[y+2] = queue[y]
		else
			hid_report_in[y+2] = 0
		end if
		y = y + 1 
	end loop
	_usb_hid_tx_report( hid_report_in, count( hid_report_in ) )
end procedure

procedure key_release_(byte in key_ind) is
	key_pressed[key_ind] = 0
	z = 0
	r = 0
	if type[key_ind] == 1 then
		modifier = modifier & !keys[key_ind]
	else
		for 6 loop 
			if queue[z] == keys[key_ind] then
				r = z
			end if
			z = z + 1
		end loop			
		while r < 6 loop
			queue[r] = queue[r+1]
			r = r + 1
		end loop
	end if
	send()
end procedure

procedure key_press_(byte in key_ind) is
	var byte y = 5
	key_pressed[key_ind] = 1
	if type[key_ind] == 1 then
		modifier = modifier | keys[key_ind]
	else
		for 6 loop 
			queue[y] = queue[y-1]
			y = y - 1
		end loop
		queue[0] = keys[key_ind]
	end if
	send()
end procedure


procedure save_data_ext_eeprom(byte in mod, byte in data) is
	_i2c_level = true
	var byte a = 0
	ee_24lc256_write(0xA0, csa, mod)
	csa = csa + 1
	ee_24lc256_write(0xA0, csa, data)
	csa = csa + 1
	a = save_mode - 2
	counter[a] = counter[a] + 1
	_i2c_level = false
	pin_b0_direction = output
end procedure

procedure log(byte in mod, byte in data) is
	_i2c_level = true
	var byte a = 0x00
	ee_24lc256_write(0xA0, cla, mod)
	cla = cla + 1
	ee_24lc256_write(0xA0, cla, data)
	cla = cla + 1
	a = save_mode - 2
	logcounter = logcounter + 1
	_i2c_level = false
	pin_b0_direction = output
end procedure

procedure play(byte in position) is
	var byte a = 0x00
	var byte b = 0x00
	var byte c = 0

	_i2c_level = true
	while c < counter[position] loop
		ee_24lc256_read(0xA0, cpa, a)
		cpa = cpa + 1
		ee_24lc256_read(0xA0, cpa, b)
		cpa = cpa + 1
		c = c + 1
		ush_keyboard_send_key( a, b )
		ush_keyboard_send_key( a, 0 )
	end loop
	_i2c_level = false
	pin_b0_direction = output
end procedure

procedure playlog() is
	var byte a = 0x00
	var byte b = 0x00
	var byte c = 0x00

	_i2c_level = true
	while c < logcounter loop
		ee_24lc256_read(0xA0, cpa, a)
		cpa = cpa + 1
		ee_24lc256_read(0xA0, cpa, b)
		cpa = cpa + 1
		c = c + 1
		ush_keyboard_send_key( a, b )
		ush_keyboard_send_key( a, 0 )
	end loop
	_i2c_level = false
	pin_b0_direction = output
end procedure

procedure set_color_single_led(byte in rr, byte in gg, byte in bb) is    
	var byte a = 0b10000000
	var byte b = 0x00

	a = 0b10000000	
	for 8 loop
		b = a & gg
		if b >= 0x01 then --GREEN
			neopixels = 1
			for 1 loop
				asm nop
			end loop
			neopixels = 0
			for 1 loop
				asm nop
			end loop
		else
			neopixels = 1
			neopixels = 0
			for 2 loop
				asm nop
			end loop
		end if
		a = a >> 1
	end loop

	a = 0b10000000	
	for 8 loop
		b = a & rr
		if b >= 0x01 then --RED
			neopixels = 1
			for 1 loop
				asm nop
			end loop
			neopixels = 0
			for 1 loop
				asm nop
			end loop
		else
			neopixels = 1
			neopixels = 0
			for 2 loop
				asm nop
			end loop
		end if
		a = a >> 1
	end loop

	a = 0b10000000	
	for 8 loop
		b = a & bb
		if b >= 0x01 then --BLUE
			neopixels = 1
			for 1 loop
				asm nop
			end loop
			neopixels = 0
			for 1 loop
				asm nop
			end loop
		else
			neopixels = 1
			neopixels = 0
			for 2 loop
				asm nop
			end loop
		end if
		a = a >> 1
	end loop
end procedure

procedure set_color(byte in rr, byte in gg, byte in bb) is    
	var byte a = 0b10000000
	var byte b = 0x00

	for 27 loop
		a = 0b10000000	
		for 8 loop
			b = a & gg
			if b >= 0x01 then --GREEN
				neopixels = 1
				for 1 loop
					asm nop
				end loop
				neopixels = 0
				for 1 loop
					asm nop
				end loop
			else
				neopixels = 1
				neopixels = 0
				for 2 loop
					asm nop
				end loop
			end if
			a = a >> 1
		end loop

		a = 0b10000000	
		for 8 loop
			b = a & rr
			if b >= 0x01 then --RED
				neopixels = 1
				for 1 loop
					asm nop
				end loop
				neopixels = 0
				for 1 loop
					asm nop
				end loop
			else
				neopixels = 1
				neopixels = 0
				for 2 loop
					asm nop
				end loop
			end if
			a = a >> 1
		end loop

		a = 0b10000000	
		for 8 loop
			b = a & bb
			if b >= 0x01 then --BLUE
				neopixels = 1
				for 1 loop
					asm nop
				end loop
				neopixels = 0
				for 1 loop
					asm nop
				end loop
			else
				neopixels = 1
				neopixels = 0
				for 2 loop
					asm nop
				end loop
			end if
			a = a >> 1
		end loop
	end loop
end procedure

set_color(red[0],green[0],blue[0])
SW_PEN = 0

var byte i = 0
for 88 loop
	key_pressed[i] = 0
	current[i] = 0
	previous[i] = 0
	bounce[i] = 0
	i = i + 1
end loop	

i = 0
for 7 loop
	queue[i] = 255
	i = i + 1
end loop

i = 0
for 8 loop
	hid_report_in[i] = 255
	i = i + 1
end loop

-- main loop
forever loop
	-- poll the usb flush function on a regular base, in order to 
	-- serve the USB requests
	usb_keyboard_flush()
	
	-- check if USB device has been configured by the HOST
	if usb_is_configured()  then
	
		-- led = usb_keyboard_led_caps_lock
		-- led2 = usb_keyboard_led_num_lock

		key_index = 0
		C1 = 1
		delay_1ms(2)
		if  R1 == high then
			current[key_index] = 1 -- 0 - ESCAPE
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R2 == high then
			current[key_index] = 1 -- 1 - BACKSLASH
		else
			current[key_index] = 0			
		end if
		key_index = key_index + 1
		if  R3 == high then
			current[key_index] = 1 -- 2 - TAB
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R4 == high then
			current[key_index] = 1 -- 3 - CAPS LOCK
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R5 == high then 
			current[key_index] = 1 -- 4 - LEFT SHIFT
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R6 == high then
			current[key_index] = 1 -- 5 - LEFT CONTROL
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		C1 = 0
		C2 = 1
		delay_1ms(2)
		if  R2 == high then
			current[key_index] = 1 -- 6 - 1
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R3 == high then
			current[key_index] = 1 -- 7 - Q
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R4 == high then
			current[key_index] = 1 -- 8 - A
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1 
		if  R5 == high then
			current[key_index] = 1 -- 9 - LESS 
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1 
		if  R6 == high then
			current[key_index] = 1 -- 10 - LEFT SUPER 
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		C2 = 0
		C3 = 1
		delay_1ms(2)
		if  R1 == high then
			current[key_index] = 1 -- 11 - F1
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R2 == high then
			current[key_index] = 1 -- 12 - 2
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R3 == high then
			current[key_index] = 1 -- 13 - W
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R4 == high then
			current[key_index] = 1 -- 14 - S
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R5 == high then
			current[key_index] = 1 -- 15 - Z
		else
			current[key_index] = 0
		end if	
		key_index = key_index + 1
		if  R6 == high then
			current[key_index] = 1 -- 16 - LEFT ALT
		else
			current[key_index] = 0
		end if	
		key_index = key_index + 1
		C3 = 0
		C4 = 1
		delay_1ms(2)
		if  R1 == high then
			current[key_index] = 1 -- 17 - F2
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R2 == high then
			current[key_index] = 1 -- 18 - 3
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R3 == high then
			current[key_index] = 1 -- 19 - E
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R4 == high then
			current[key_index] = 1 -- 20 - D
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R5 == high then
			current[key_index] = 1 -- 21 - X
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		C4 = 0
		C5 = 1
		delay_1ms(2)
		if  R1 == high then
			current[key_index] = 1 -- 22 - F3
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R2 == high then
			current[key_index] = 1 -- 23 - 4
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R3 == high then
			current[key_index] = 1 -- 24 - R
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R4 == high then
			current[key_index] = 1 -- 25 - F
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R5 == high then
			current[key_index] = 1 -- 26 - C
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		C5 = 0
		C6 = 1
		delay_1ms(2)		
		if  R1 == high then
			current[key_index] = 1 -- 27 - F4
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R2 == high then
			current[key_index] = 1 -- 28 - 5
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R3 == high then
			current[key_index] = 1 -- 29 - T
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R4 == high then
			current[key_index] = 1 -- 30 - G
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R5 == high then
			current[key_index] = 1 -- 31 - V
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		C6 = 0
		C7 = 1
		delay_1ms(2)
		if  R1 == high then
			current[key_index] = 1 -- 32 - F5
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R2 == high then
			current[key_index] = 1 -- 33 - 6
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R3 == high then
			current[key_index] = 1 -- 34 - Y
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R4 == high then
			current[key_index] = 1 -- 35 - H
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R5 == high then
			current[key_index] = 1 -- 36 - B
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R6 == high then
			current[key_index] = 1 -- 37 - SPACE
		else
			current[key_index] = 0
		end if		
		key_index = key_index + 1
		C7 = 0
		C8 = 1
		delay_1ms(2)
		if  R1 == high then
			current[key_index] = 1 -- 38 - F6
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R2 == high then
			current[key_index] = 1 -- 39 - 7
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R3 == high then
			current[key_index] = 1 -- 40 - U
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R4 == high then
			current[key_index] = 1 -- 41 - J
		else
			current[key_index] = 0	
		end if
		key_index = key_index + 1
		if  R5 == high then
			current[key_index] = 1 -- 42 - N
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		C8 = 0
		C9 = 1
		delay_1ms(2)
		if  R1 == high then
			current[key_index] = 1 -- 43 - F7
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R2 == high then
			current[key_index] = 1 -- 44 - 8
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R3 == high then
			current[key_index] = 1 -- 45 - I
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R4 == high then
			current[key_index] = 1 -- 46 - K
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R5 == high then
			current[key_index] = 1 -- 47 - M
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		C9 = 0
		C10 = 1
		delay_1ms(2)
		if  R1 == high then
			current[key_index] = 1 -- 48 - F8		
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R2 == high then
			current[key_index] = 1 -- 49 - 9
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R3 == high then
			current[key_index] = 1 -- 50 - O
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R4 == high then
			current[key_index] = 1 -- 51 - L
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R5 == high then
			current[key_index] = 1 -- 52 - COMMA
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R6 == high then
			current[key_index] = 1 -- 53 - RIGHT ALT
		else
			current[key_index] = 0
		end if	
		key_index = key_index + 1
		C10 = 0
		C11 = 1
		delay_1ms(2)
		if  R1 == high then
			current[key_index] = 1 -- 54 - F9
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R2 == high then
			current[key_index] = 1 -- 55 - 0
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R3 == high then
			current[key_index] = 1 -- 56 - P
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R4 == high then
			current[key_index] = 1 -- 57 - Ç
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R5 == high then
			current[key_index] = 1 -- 58 - PERIOD
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R6 == high then
			current[key_index] = 1 -- 59 - RIGHT GUI
		else
			current[key_index] = 0
		end if	
		key_index = key_index + 1
		C11 = 0
		C12 = 1
		delay_1ms(2)
		if  R1 == high then
			current[key_index] = 1 -- 60 - F10
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R2 == high then
			current[key_index] = 1 -- 61 - APOSTROPHE
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R3 == high then
			current[key_index] = 1 -- 62 - PLUS
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R4 == high then
			current[key_index] = 1 -- 63 - MASCULINE
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R5 == high then
			current[key_index] = 1 -- 64 - MINUS
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		C12 = 0
		C13 = 1
		delay_1ms(2)
		if  R1 == high then
			current[key_index] = 1 -- 65 - F11
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R2 == high then
			current[key_index] = 1 -- 66 - GUILLEMOT LEFT
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R3 == high then
			current[key_index] = 1 -- 67 - DEAD ACUTE
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R4 == high then
			current[key_index] = 1 -- 68 - TILDE
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R6 == high then
			current[key_index] = 1 -- 69 - MENU
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		C13 = 0
		C14 = 1
		delay_1ms(2)
		if  R1 == high then
			current[key_index] = 1 -- 70 - F12
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R2 == high then
			current[key_index] = 1 -- 71 - BACKSPACE
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R3 == high then
			current[key_index] = 1 -- 72 - ENTER
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R4 == high then 
			current[key_index] = 1 -- 73 - RIGHT SHIFT
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R6 == high then
			current[key_index] = 1 -- 74 - RIGHT CONTROL
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		C14 = 0
		C15 = 1
		delay_1ms(2)
		if  R1 == high then
			current[key_index] = 1 -- 75 - PRINT SCREEN
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R2 == high then
			current[key_index] = 1 -- 76 - INSERT
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R3 == high then
			current[key_index] = 1 -- 77 - DELETE
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R5 == high then
			current[key_index] = 1 -- 78 - LEFT ARROW
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		C15 = 0
		C16 = 1
		delay_1ms(2)
		if  R1 == high then
			current[key_index] = 1 -- 79 - SCROLL LOCK
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R2 == high then
			current[key_index] = 1 -- 80 - HOME
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R3 == high then
			current[key_index] = 1 -- 81 - END
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R4 == high then
			current[key_index] = 1 -- 82 - UP ARROW
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R5 == high then
			current[key_index] = 1 -- 83 - DOWN ARROW
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		C16 = 0
		C17 = 1
		delay_1ms(2)
		if  R1 == high then
			current[key_index] = 1 -- 84 - PAUSE
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R2 == high then
			current[key_index] = 1 -- 85 - PAGE UP
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R3 == high then
			current[key_index] = 1 -- 86 - PAGE DOWN
		else
			current[key_index] = 0
		end if
		key_index = key_index + 1
		if  R5 == high then
			current[key_index] = 1 -- 87 - RIGHT ARROW
		else
			current[key_index] = 0			
		end if
		C17 = 0

		d = 0
		for 88 loop			
			if current[d] == 1 & previous[d] == 0 then	
				timecounter = 0
				if key_pressed[d] == 0 then

-- ************************ SPECIAL FUNCTIONS ***********************

					if d == 84 then -- PAUSE, ENTER/QUIT SPECIAL MODE
						inhibit = 1
						if mode == 0 then
							mode = 1
							set_color(red[1], green[1], blue[1])
						else
							set_color(red[0], green[0], blue[0])
							if save_mode > 1 then
								aux = 20 + (save_mode-2)*2
								aux2 = save_mode - 2
								data_eeprom_write_dword(aux,counter[aux2])
							end if
							mode = 0
							save_mode = 0
						end if
					end if

					if d == 14 then -- S, TO ENTER SAVE MODE
						if mode == 1 & save_mode < 1 then
							save_mode = 1
							set_color(red[2], green[2], blue[2])
							inhibit = 1
						end if
					end if

					if d == 46 then -- K, TO PLAY THE LOG
						if mode == 1 & save_mode == 0 then
							inhibit = 1
							mode = 0
							cpa = 0x708
							set_color(red[0], green[0], blue[0])
							playlog()
						end if
					end if					

					if d == 51 then -- L, TO ENTER LOG MODE
						if mode == 1 & save_mode == 0 then
							inhibit = 1
							mode = 0
							set_color(red[0], green[0], blue[0])
							if log_mode == 0 then
								log_mode = 1
								data_eeprom_write(12,log_mode)
								logcounter = 0
								cla = 0x708
							else
								log_mode = 0
								data_eeprom_write(12,log_mode)
								data_eeprom_write_dword(44,logcounter)
							end if
						end if
					end if					

					if d == 24 then -- R, TO CHANGE RED
						if mode == 1 & save_mode == 0 then
							inhibit = 1
							if color_mode == 1 then
								color_mode = 0
							else 
								color_mode = 1
							end if
						end if
					end if					
					if d == 30 then -- G, TO CHANGE GREEN
						if mode == 1 & save_mode == 0 then
							inhibit = 1
							if color_mode == 2 then
								color_mode = 0
							else 
								color_mode = 2
							end if
						end if
					end if				
					if d == 36 then -- B, TO CHANGE BLUE
						if mode == 1 & save_mode == 0 then
							inhibit = 1
							if color_mode == 3 then
								color_mode = 0
							else 
								color_mode = 3
							end if							
						end if
					end if	

					if d == 68 then -- TILDE, TO CHANGE LED MODE 2
						if mode == 1 & save_mode == 0 then
							inhibit = 1
							if ledmode != 2 then
								rgbColour[0] = 120
								rgbColour[1] = 0
								rgbColour[2] = 0
								ledmode = 2
								mode = 0
							else 
								ledmode = 0
								set_color(red[0],green[0],blue[0])
								mode = 0
							end if							
						end if
					end if	
					if d == 63 then -- MASCULINE, TO CHANGE LED MODE 3
						if mode == 1 & save_mode == 0 then
							inhibit = 1
							if ledmode != 3 then
								ledmode = 3
								mode = 0
							else 
								ledmode = 0
								set_color(red[0],green[0],blue[0])
								mode = 0
							end if							
						end if
					end if	
					if d == 57 then -- Ç, TO CHANGE LED MODE 4
						if mode == 1 & save_mode == 0 then
							inhibit = 1
							if ledmode != 4 then
								ledmode = 4
								mode = 0
							else 
								ledmode = 0
								set_color(red[0],green[0],blue[0])
								mode = 0
							end if							
						end if
					end if											

					if d == 62 then -- +, TO INCREASE SELECTED COLOR COMPONENT
						if mode == 1 & save_mode == 0 then
							inhibit = 1
							if color_mode == 1 then
								if red_ <= 120 then
									red_ = red_ + 10
								end if 
								set_color(red_,green_,blue_)
							elsif color_mode == 2 then
								if green_ <= 120 then
									green_ = green_ + 10
								end if 
								set_color(red_,green_,blue_)
							elsif color_mode == 3 then
								if blue_ <= 120 then
									blue_ = blue_ + 10
								end if 
								set_color(red_,green_,blue_)
							end if
						end if
					end if							
					if d == 64 then -- -, TO REDUCE SELECTED COLOR COMPONENT
						if mode == 1 & save_mode == 0 then
							inhibit = 1
							if color_mode == 1 then
								if red_ >= 10 then
									red_ = red_ - 10
								end if 
								set_color(red_,green_,blue_)
							elsif color_mode == 2 then
								if green_ >= 10 then
									green_ = green_ - 10
								end if 
								set_color(red_,green_,blue_)
							elsif color_mode == 3 then
								if blue_ >= 10 then
									blue_ = blue_ - 10
								end if 
								set_color(red_,green_,blue_)
							end if
						end if
					end if	

					if d == 56 then -- P, TO ACTIVATE THE PEN
						if mode == 1 & save_mode == 0 then
							if SW_PEN == 1 then
								SW_PEN = 0
							else
								SW_PEN = 1
							end if
							mode = 0
							set_color(red[0],green[0],blue[0])
							inhibit = 1
						end if
					end if

					if d == 26 then -- C, TO SAVE LEVEL 1 COLOR
						if mode == 1 & save_mode == 0 then
							data_eeprom_write(0,red_)
							data_eeprom_write(1,green_)
							data_eeprom_write(2,blue_)
							red[0] = red_
							green[0] = green_
							blue[0] = blue_
						end if
					end if	
					if d == 20 then -- D, TO SAVE LEVEL 2 COLOR
						if mode == 1 & save_mode == 0 then
							inhibit = 1
							data_eeprom_write(3,red_)
							data_eeprom_write(4,green_)
							data_eeprom_write(5,blue_)
							red[1] = red_
							green[1] = green_
							blue[1] = blue_
						end if
					end if
					if d == 19 then -- E, TO SAVE LEVEL 3 COLOR
						if mode == 1 & save_mode == 0 then
							inhibit = 1
							data_eeprom_write(6,red_)
							data_eeprom_write(7,green_)
							data_eeprom_write(8,blue_)
							red[2] = red_
							green[2] = green_
							blue[2] = blue_
						end if
					end if
					if d == 18 then -- 3, TO SAVE LEVEL 4 COLOR
						if mode == 1 & save_mode == 0 then
							inhibit = 1
							data_eeprom_write(9,red_)
							data_eeprom_write(10,green_)
							data_eeprom_write(11,blue_)
							red[3] = red_
							green[3] = green_
							blue[3] = blue_
						end if
					end if
					
					g = 0
					while g < 12 loop
						if mode == 1 & save_mode < 1 then
							if d == f_index[g] then
								set_color(red[0], green[0], blue[0])
								mode = 0
								save_mode = 0
								inhibit = 1
								cpa = ssa[g]
								play(g)
							end if
						end if
						g = g + 1
					end loop			

					if save_mode == 1 then
						g = 0
						while g < 12 loop
							if d == f_index[g] then
								set_color(red[3], green[3], blue[3])
								inhibit = 1
								counter[g] = 0
								csa = ssa[g]
								save_mode = g + 2 	
							end if
							g = g + 1
						end loop
					elsif save_mode > 1 & type[d]!= 1 then
						save_data_ext_eeprom(modifier,keys[d])
						save_data_ext_eeprom(modifier,0)
					end if

					if log_mode == 1 then
						if inhibit == 0 & type[d]!= 1 then
							log(modifier,keys[d])
							log(modifier,0)
						end if
						if logcounter > 400000 then
							log_mode = 0
							data_eeprom_write_dword(44,logcounter)
						end if
					end if

-- ******************** END OF SPECIAL FUNCTIONS ********************

				if inhibit == 1 then
					inhibit = 0	
				else
					key_press_(d)
				end if

				end if
			elsif previous[d] == 1 & current[d] == 0 then
				if key_pressed[d] == 1 then
					key_pressed[d] = 0
					key_release_(d)
				end if
			end if
			previous[d] = current[d]
			d = d + 1
		end loop 
		if timecounter < 1800 then
			timecounter = timecounter + 1
		end if

		if timecounter >= 1800 & ledmode == 0 then
			rgbColour[0] = red[0]
			rgbColour[1] = green[0]
			rgbColour[2] = blue[0]
			--set_color(0,0,0)
			ledmode = 1
		elsif ledmode == 1 & timecounter < 1800 then
			set_color(red[0],green[0],blue[0])
			ledmode = 0
		end if 

		if ledmode == 1 | ledmode == 4 then
			colorfactorR = 1
			colorfactorG = 1
			colorfactorB = 1
			if rgbColour[0] > 30 then
				colorfactorR = 2
			end if
			if rgbColour[0] > 60 then
				colorfactorR = 3
			end if
			if rgbColour[0] > 90 then
				colorfactorR = 4
			end if
			if rgbColour[1] > 30 then
				colorfactorG = 2
			end if
			if rgbColour[1] > 60 then
				colorfactorG = 3
			end if
			if rgbColour[1] > 90 then
				colorfactorG = 4
			end if
			if rgbColour[2] > 30 then
				colorfactorB = 2
			end if
			if rgbColour[2] > 60 then
				colorfactorB = 3
			end if
			if rgbColour[2] > 90 then
				colorfactorB = 4
			end if

			if direction == 0 then
				if rgbColour[0] >= colorfactorR then
					rgbColour[0] = rgbColour[0] - colorfactorR
				end if
				if rgbColour[1] >= colorfactorG then
					rgbColour[1] = rgbColour[1] - colorfactorG
				end if
				if rgbColour[2] >= colorfactorB then
					rgbColour[2] = rgbColour[2] - colorfactorB
				end if
				if rgbColour[0] < colorfactorR & rgbColour[1] < colorfactorG & rgbColour[2] < colorfactorB then
					direction = 1
				end if
			else
				if rgbColour[0] < red[0] then
					rgbColour[0] = rgbColour[0] + colorfactorR
				end if
				if rgbColour[1] < green[0] then
					rgbColour[1] = rgbColour[1] + colorfactorG
				end if
				if rgbColour[2] < blue[0] then
					rgbColour[2] = rgbColour[2] + colorfactorB
				end if
				if rgbColour[0] >= red[0] & rgbColour[1] >= green[0] & rgbColour[2] >= blue[0] then
					direction = 0
				end if
			end if
			set_color(rgbColour[0],rgbColour[1],rgbColour[2])
		end if

		if ledmode == 2 then
			if decColor == 2 then
				incColor = 0
			else
				incColor = decColor + 1
			end if

			if rgbColour[incColor] < 120 then
				rgbColour[incColor] = rgbColour[incColor] + 1
				rgbColour[decColor] = rgbColour[decColor] - 1
			else
				decColor = decColor + 1
			end if 

			if decColor == 3 then
				decColor = 0
			end if
			set_color(rgbColour[0],rgbColour[1],rgbColour[2])
		end if

		if ledmode == 3 then
			d = 1
			for 27 loop
				if d == pos then
					set_color_single_led(red[0],green[0],blue[0])
				else
					set_color_single_led(0,0,0)
				end if
				d = d + 1
			end loop

			if direction == 1 then
				pos = pos + 1
				if pos == 28 then
					direction = 0
					pos = 26
				end if
			else
				pos = pos - 1
				if pos == 0 then
					direction = 1
					pos = 2
				end if
			end if

		end if

		--ee_24lc256_write(0xA0, 1, 0x38)  -- write "A" to 24lc256
   		--ee_24lc256_read(0xA0, 1, data)  -- read from 24lc256
   		--ush_keyboard_send_key( modifier, data ) -- MINUS
		--ush_keyboard_send_key( 0, 0 )
		--delay_1ms(2000)

		--ee_24lc256_write(0xA0, 0, 0x14)  -- write "A" to 24lc256
		--ee_24lc256_write(0xA0, 2, 0x1A)  -- write "A" to 24lc256
		--ee_24lc256_write(0xA0, 4, 0x08)  -- write "A" to 24lc256
		--ee_24lc256_read(0xA0, 0, data)  -- read from 24lc256
   		--ush_keyboard_send_key( modifier, data ) -- MINUS
		--ush_keyboard_send_key( 0, 0 )
		--ee_24lc256_read(0xA0, 2, data)  -- read from 24lc256
   		--ush_keyboard_send_key( modifier, data ) -- MINUS
		--ush_keyboard_send_key( 0, 0 )
		--ee_24lc256_read(0xA0, 4, data)  -- read from 24lc256
   		--ush_keyboard_send_key( modifier, data ) -- MINUS
		--ush_keyboard_send_key( 0, 0 )
		--delay_1ms(2000)
		
	end if
end loop